use optstr_curl::parse_input_file;
use optstr_curl::OptStr;

pub fn do_gen_src() -> anyhow::Result<()> {
    let (vec_optstr, vec_line) = parse_input_file("comps/common/optstr-curl/src/curl.cmd.txt")?;
    //
    let sss = do_gen_src_help(&vec_optstr, &vec_line)?;
    update_file::update_file(&sss, "comps/cmp_argh/src/curl.cmd.help.rs.txt")?;
    //
    let sss = do_gen_src_match(&vec_optstr, &vec_line)?;
    update_file::update_file(&sss, "comps/cmp_argh/src/curl.cmd.match.rs.txt")?;
    //
    Ok(())
}

fn do_gen_src_help(vec_optstr: &[OptStr], _vec_line: &[String]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    sss += r#"
"#;
    //
    sss += r#"
#[derive(Debug, Default, PartialEq)]
pub struct CmdOptConf {
    pub opt_program: String,
    //
"#;
    for rec in vec_optstr.iter() {
        sss += &format!("    pub {}: {},\n", rec.field_s, rec.type_s);
    }
    sss += r#"    //
    pub arg_params: Vec<String>,
}
"#;
    //
    sss += r#"
#[derive(FromArgs, PartialEq, Debug)]
/// transfer a URL, another name is the multiprotocol getter
pub struct MyOptions {
"#;
    for rec in vec_optstr.iter() {
        if rec.enum_s == "Help" {
            continue;
        }
        if rec.enum_s == "Version" {
            continue;
        }
        sss += &format!("    /// {}\n", rec._comment.to_ascii_lowercase());
        sss += "    #[argh(\n";
        if rec.type_s == "bool" {
            sss += "        switch,\n";
        } else {
            sss += "        option,\n";
        }
        if !rec.sho.is_empty() {
            sss += &format!("        short = '{}',\n", rec.sho);
        }
        sss += &format!("        long = \"{}\",\n", fit_longname(&rec.lon));
        sss += "    )]\n";
        if rec.type_s == "bool" {
            sss += &format!("    pub {}: bool,\n", rec.field_s);
        } else {
            sss += &format!("    pub {}: Option<{}>,\n", rec.field_s, rec.type_s);
        }
    }
    sss += r#"
    #[argh(positional)]
    arg_input: String,
}
"#;
    //
    Ok(sss)
}

fn do_gen_src_match(vec_optstr: &[OptStr], _vec_line: &[String]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    sss += r#"
{
"#;
    //
    for rec in vec_optstr.iter() {
        if rec.enum_s == "Help" {
            continue;
        }
        if rec.enum_s == "Version" {
            continue;
        }
        if rec.type_s == "bool" {
            sss += &format!("        conf.{} = opts.{};\n", rec.field_s, rec.field_s);
        } else {
            sss += &format!("    if let Some(v) = opts.{} {{\n", rec.field_s);
            sss += &format!("        conf.{} = v;\n", rec.field_s);
            sss += "    }\n";
        }
    }
    sss += r#"
}
"#;
    //
    Ok(sss)
}

fn fit_longname(s: &str) -> String {
    let s = s.replace("100", "handreds");
    let s = s.replace("0.9", "onine");
    let s = s.replace("1.0", "onepzero");
    let s = s.replace("1.1", "onepone");
    let s = s.replace("1.2", "oneptwo");
    let s = s.replace("1.3", "onepthree");
    let s = s.replace("0", "zero");
    let s = s.replace("1", "one");
    let s = s.replace("2", "two");
    let s = s.replace("3", "three");
    let s = s.replace("4", "four");
    let s = s.replace("5", "five");
    let s = s.replace("6", "six");
    s.to_string()
}
