use optstr_curl::parse_input_file;
use optstr_curl::OptStr;
use std::cmp::Ordering;

pub fn do_gen_src() -> anyhow::Result<()> {
    let (vec_optstr, vec_line) = parse_input_file("comps/common/optstr-curl/src/curl.cmd.txt")?;
    //
    let sss = do_gen_src_help(&vec_optstr, &vec_line)?;
    update_file::update_file(&sss, "comps/cmp_flood_tide/src/curl.cmd.help.rs.txt")?;
    //
    let sss = do_gen_src_match(&vec_optstr)?;
    update_file::update_file(&sss, "comps/cmp_flood_tide/src/curl.cmd.match.rs.txt")?;
    //
    Ok(())
}

fn do_gen_src_help(vec_optstr: &[OptStr], vec_line: &[String]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    sss += r#"
const OPTIONS_TEXT: &str = r""#;
    for line in vec_line {
        sss += &format!("{}\n", line);
    }
    sss += "\";\n";
    //
    sss += r#"
#[repr(u8)]
#[derive(Debug, PartialEq)]
enum CmdOP {
"#;
    for rec in vec_optstr.iter() {
        sss += &format!("    {},\n", rec.enum_s);
    }
    sss += "}\n";
    sss += r#"
impl std::convert::From<u8> for CmdOP {
    fn from(value: u8) -> Self {
        unsafe { std::mem::transmute(value) }
    }
}
impl CmdOP {
    pub const fn to(self) -> OptNum {
        self as OptNum
    }
}
"#;
    //
    let vec_optstr_sorted = {
        let mut target: Vec<&OptStr> = vec_optstr.iter().map(|o| o).collect();
        target.sort_by(|&a, &b| match a.lon.cmp(&b.lon) {
            Ordering::Less => Ordering::Less,
            Ordering::Greater => Ordering::Greater,
            Ordering::Equal => match a.sho.cmp(&b.sho) {
                Ordering::Less => Ordering::Less,
                Ordering::Greater => Ordering::Greater,
                Ordering::Equal => a.num.cmp(&b.num),
            },
        });
        target
    };
    //
    let s = r#"
#[rustfmt::skip]
const OPT_ARY: [Opt;"#;
    sss += &format!("{}{}] = [\n", s, vec_optstr_sorted.len());
    for rec in vec_optstr_sorted.iter() {
        sss += "    Opt { ";
        if rec.sho.is_empty() {
            sss += "sho: 0u8,  ";
        } else {
            sss += &format!("sho: b'{}', ", rec.sho);
        }
        let s = "\"".to_string() + &rec.lon + "\",";
        sss += &format!("lon: {:-17}", s);
        sss += if rec.meta.is_empty() {
            "has: Arg::No,  "
        } else {
            "has: Arg::Yes, "
        };
        sss += &format!("num: CmdOP::{}.to(), ", rec.enum_s);
        sss += "},\n";
    }
    sss += "];\n";
    //
    let mut vec_optstr_sho_idx: Vec<(_, usize)> = vec_optstr_sorted
        .iter()
        .enumerate()
        .filter(|(_, &o)| !o.sho.is_empty())
        .map(|(i, &o)| (&o.sho, i))
        .collect();
    vec_optstr_sho_idx.sort_by(|a, b| a.0.cmp(&b.0));
    //
    let s = r#"
#[rustfmt::skip]
const OPT_ARY_SHO_IDX: [(u8,usize);"#;
    sss += &format!("{}{}] = [\n", s, vec_optstr_sho_idx.len());
    for elm in vec_optstr_sho_idx.iter() {
        sss += &format!("(b'{}',{}),", elm.0, elm.1);
    }
    sss += "];\n";
    //
    sss += r#"
#[derive(Debug, Default, PartialEq)]
pub struct CmdOptConf {
    pub opt_program: String,
    //
"#;
    for rec in vec_optstr.iter() {
        sss += &format!("    pub {}: {},\n", rec.field_s, rec.type_s);
    }
    sss += r#"    //
    pub arg_params: Vec<String>,
}
"#;
    //
    Ok(sss)
}

fn do_gen_src_match(vec_optstr: &[OptStr]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    //
    sss += r#"
match CmdOP::from(nv.opt.num) {
"#;
    for rec in vec_optstr.iter() {
        sss += &format!("    CmdOP::{} => {{\n", rec.enum_s);
        match rec.type_s.as_str() {
            "bool" => match rec.enum_s.as_str() {
                "Help" => {
                    sss += "        print_help_and_exit(conf);\n";
                }
                "Version" => {
                    sss += "        print_version_and_exit(conf);\n";
                }
                _ => {
                    sss += &format!("        conf.{} = true;\n", rec.field_s);
                }
            },
            "String" => {
                sss += &format!("        conf.{} = value_to_string(nv)?;\n", rec.field_s);
            }
            "u32" => {
                sss += &format!("        conf.{} = value_to_u32(nv)?;\n", rec.field_s);
            }
            "u64" => {
                sss += &format!("        conf.{} = value_to_u64(nv)?;\n", rec.field_s);
            }
            _ => unreachable!(),
        }
        sss += "    }\n";
    }
    sss += r#"}
"#;
    //
    Ok(sss)
}
