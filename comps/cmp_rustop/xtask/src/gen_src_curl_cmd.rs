use anyhow::Context;
use std::io::BufRead;

pub fn do_gen_src() -> anyhow::Result<()> {
    let (vec_optstr, vec_line) =
        parse_input_file("comps/cmp_rustop/xtask/src/rustop.curl.cmd.txt")?;
    //
    let sss = do_gen_src_help(&vec_optstr, &vec_line)?;
    update_file::update_file(&sss, "comps/cmp_rustop/src/curl.cmd.help.rs.txt")?;
    //
    let sss = do_gen_src_match(&vec_optstr)?;
    update_file::update_file(&sss, "comps/cmp_rustop/src/curl.cmd.match.rs.txt")?;
    //
    let sss = do_gen_src_lex(&vec_optstr)?;
    update_file::update_file(&sss, "comps/cmp_rustop/src/curl.cmd.lex.rs.txt")?;
    //
    Ok(())
}

fn do_gen_src_help(vec_optstr: &[OptStr], _vec_line: &[String]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    sss += r#"
"#;
    //
    sss += r#"
#[derive(Debug, Default, PartialEq)]
pub struct CmdOptConf {
    pub opt_program: String,
    //
"#;
    for rec in vec_optstr.iter() {
        sss += &format!("    pub {}: {},\n", rec.field_s, rec.type_s);
    }
    sss += r#"    //
    pub arg_params: Vec<String>,
}
"#;
    //
    Ok(sss)
}

fn do_gen_src_match(vec_optstr: &[OptStr]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    sss += r#"
{
"#;
    //
    for rec in vec_optstr.iter() {
        let sholon = if !rec.lon.is_empty() {
            rec.lon.clone()
        } else {
            rec.sho.clone()
        };
        match rec.type_s.as_str() {
            "bool" => match rec.enum_s.as_str() {
                "Help" => {
                    /*
                                        sss += r#"
                    if ropa.flg_help {
                        print_help_and_exit(&conf);
                    }
                    "#;
                    */
                }
                "Version" => {
                    sss += r#"
if ropa.version {
    print_version_and_exit(&conf);
}
"#;
                }
                _ => {
                    sss += &format!("    conf.{} = ropa.{};\n", rec.field_s, rec.field_s);
                }
            },
            "String" => {
                sss += &format!(
                    "    conf.{} = value_to_string(\"{}\", ropa.{})?;\n",
                    rec.field_s, sholon, rec.field_s
                );
            }
            "u32" => {
                sss += &format!(
                    "    conf.{} = value_to_u32(\"{}\", ropa.{})?;\n",
                    rec.field_s, sholon, rec.field_s
                );
            }
            "u64" => {
                sss += &format!(
                    "    conf.{} = value_to_u64(\"{}\", ropa.{})?;\n",
                    rec.field_s, sholon, rec.field_s
                );
            }
            _ => unreachable!(),
        }
    }
    sss += r#"
    conf.arg_params.push(ropa.input);
}
"#;
    //
    Ok(sss)
}

fn do_gen_src_lex(vec_optstr: &[OptStr]) -> anyhow::Result<String> {
    let mut sss = String::with_capacity(4 * 1024);
    //
    let s = r"// WARN: This file is auto generated by";
    sss += &format!("{} {}", s, env!("CARGO_PKG_NAME"));
    //
    sss += r#"
opts! {
    auto_shorts     false;
    command_name    env!("CARGO_PKG_NAME");
    help            true;
"#;
    for rec in vec_optstr.iter() {
        match rec.type_s.as_str() {
            "bool" => match rec.enum_s.as_str() {
                "Help" => {
                    //sss += &format!("    opt version:bool, short:'{}', long:\"{}\", desc:\"{}\";\n", rec.sho, rec.lon, rec._comment);
                }
                "Version" => {
                    sss += &format!(
                        "    opt version:bool, short:'{}', long:\"{}\", desc:\"{}\";\n",
                        rec.sho, rec.lon, rec._comment
                    );
                }
                _ => {
                    if !rec.sho.is_empty() && !rec.lon.is_empty() {
                        sss += &format!(
                            "    opt {}:bool, short:'{}', long:\"{}\", desc:\"{}\";\n",
                            rec.field_s, rec.sho, rec.lon, rec._comment
                        );
                    } else if !rec.sho.is_empty() {
                        sss += &format!(
                            "    opt {}:bool, short:'{}', desc:\"{}\";\n",
                            rec.field_s, rec.sho, rec._comment
                        );
                    } else {
                        sss += &format!(
                            "    opt {}:bool, long:\"{}\", desc:\"{}\";\n",
                            rec.field_s, rec.lon, rec._comment
                        );
                    }
                }
            },
            "String" => {
                if !rec.sho.is_empty() && !rec.lon.is_empty() {
                    sss += &format!(
                        "    opt {}:Option<String>, short:'{}', long:\"{}\", desc:\"{}\";\n",
                        rec.field_s, rec.sho, rec.lon, rec._comment
                    );
                } else if !rec.sho.is_empty() {
                    sss += &format!(
                        "    opt {}:Option<String>, short:'{}', desc:\"{}\";\n",
                        rec.field_s, rec.sho, rec._comment
                    );
                } else {
                    sss += &format!(
                        "    opt {}:Option<String>, long:\"{}\", desc:\"{}\";\n",
                        rec.field_s, rec.lon, rec._comment
                    );
                }
            }
            "u32" => {
                if !rec.sho.is_empty() && !rec.lon.is_empty() {
                    sss += &format!(
                        "    opt {}:Option<u32>, short:'{}', long:\"{}\", desc:\"{}\";\n",
                        rec.field_s, rec.sho, rec.lon, rec._comment
                    );
                } else if !rec.sho.is_empty() {
                    sss += &format!(
                        "    opt {}:Option<u32>, short:'{}', desc:\"{}\";\n",
                        rec.field_s, rec.sho, rec._comment
                    );
                } else {
                    sss += &format!(
                        "    opt {}:Option<u32>, long:\"{}\", desc:\"{}\";\n",
                        rec.field_s, rec.lon, rec._comment
                    );
                }
            }
            "u64" => {
                if !rec.sho.is_empty() && !rec.lon.is_empty() {
                    sss += &format!(
                        "    opt {}:Option<u64>, short:'{}', long:\"{}\", desc:\"{}\";\n",
                        rec.field_s, rec.sho, rec.lon, rec._comment
                    );
                } else if !rec.sho.is_empty() {
                    sss += &format!(
                        "    opt {}:Option<u64>, short:'{}', desc:\"{}\";\n",
                        rec.field_s, rec.sho, rec._comment
                    );
                } else {
                    sss += &format!(
                        "    opt {}:Option<u64>, long:\"{}\", desc:\"{}\";\n",
                        rec.field_s, rec.lon, rec._comment
                    );
                }
            }
            _ => unreachable!(),
        }
    }
    sss += r#"
    param input:String, name:"<URL>", desc:"url";
"#;
    sss += r#"
}
"#;
    //
    Ok(sss)
}

#[derive(Default)]
struct OptStr {
    sho: String,      // short option
    lon: String,      // long option
    opt: String,      // option's option
    _comment: String, // option comment
    type_s: String,   // type string
    enum_s: String,   // enume field string
    field_s: String,  // struct field string
}

impl OptStr {
    fn to_enum(&self) -> String {
        let r = &self.lon;
        let v: Vec<_> = r
            .split('-')
            .map(|w| {
                let mut cs: Vec<char> = w.chars().collect();
                cs[0] = cs[0].to_ascii_uppercase();
                let mut s = String::new();
                for c in cs {
                    s.push(if c == '.' { '_' } else { c });
                }
                s
            })
            .collect();
        v.join("")
    }
    fn to_field(&self) -> String {
        let mut s = String::with_capacity(self.lon.len());
        for c in self.lon.chars() {
            #[rustfmt::skip]
            let c = match c { '-' => '_', '.' => '_', _ => c, };
            s.push(c);
        }
        let prefix = if self.opt.is_empty() { "flg_" } else { "opt_" };
        prefix.to_string() + &s
    }
}

fn parse_input_file(in_file: &str) -> anyhow::Result<(Vec<OptStr>, Vec<String>)> {
    let mut vec_line: Vec<String> = Vec::new();
    let mut vec_optstr: Vec<OptStr> = Vec::new();
    //
    let re_1 = regex::Regex::new(r"^ *-([^ ]) +--([^ ]+) +(<.+>) +([^ ].*)$").unwrap();
    let re_2 = regex::Regex::new(r"^ *-([^ ]) +--([^ ]+) +([^ ].*)$").unwrap();
    let re_3 = regex::Regex::new(r"^ +--([^ ]+) +(<.+>) +([^ ].*)$").unwrap();
    let re_4 = regex::Regex::new(r"^ +--([^ ]+) +([^ ].*)$").unwrap();
    //
    let reader = std::io::BufReader::new(
        std::fs::File::open(in_file)
            .with_context(|| format!("could not open file `{}`", in_file))?,
    );
    for line in reader.lines() {
        let line = line?;
        if let Some(caps) = re_1.captures(&line) {
            //  -C  --continue-at <offset>        Resumed transfer offset
            vec_optstr.push(OptStr {
                sho: caps[1].to_string(),
                lon: caps[2].to_string(),
                opt: caps[3].to_string(),
                _comment: caps[4].to_string(),
                ..OptStr::default()
            });
        } else if let Some(caps) = re_2.captures(&line) {
            //  -q  --disable             Disable .curlrc
            vec_optstr.push(OptStr {
                sho: caps[1].to_string(),
                lon: caps[2].to_string(),
                opt: "".to_string(),
                _comment: caps[3].to_string(),
                ..OptStr::default()
            });
        } else if let Some(caps) = re_3.captures(&line) {
            //      --data-binary <data>  HTTP POST binary data
            vec_optstr.push(OptStr {
                sho: "".to_string(),
                lon: caps[1].to_string(),
                opt: caps[2].to_string(),
                _comment: caps[3].to_string(),
                ..OptStr::default()
            });
        } else if let Some(caps) = re_4.captures(&line) {
            //      --digest              Use HTTP Digest Authentication
            vec_optstr.push(OptStr {
                sho: "".to_string(),
                lon: caps[1].to_string(),
                opt: "".to_string(),
                _comment: caps[2].to_string(),
                ..OptStr::default()
            });
        } else {
            unreachable!();
        }
        vec_line.push(line);
    }
    //
    for v in &mut vec_optstr {
        let v_type = if v.opt.is_empty() { "bool" } else { "String" };
        let v_type = match v.lon.as_str() {
            "connect-timeout" => "u32",
            "continue-at" => "u64",
            "expect100-timeout" => "u32",
            "happy-eyeballs-timeout-ms" => "u64",
            "keepalive-time" => "u32",
            "limit-rate" => "u64",
            "max-filesize" => "u64",
            "max-redirs" => "u32",
            "max-time" => "u32",
            "retry" => "u32",
            "retry-delay" => "u32",
            "retry-max-time" => "u32",
            "speed-limit" => "u64",
            "speed-time" => "u32",
            "tftp-blksize" => "u32",
            _ => v_type,
        };
        //
        v.type_s = v_type.to_string();
        v.enum_s = v.to_enum();
        v.field_s = v.to_field();
    }
    //
    Ok((vec_optstr, vec_line))
}
